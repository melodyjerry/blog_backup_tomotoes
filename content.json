{"meta":{"title":"MelodyHub","subtitle":"你用走 可是我用跑","description":"","author":"Melody Jerry","url":"http://yoursite.com","root":"/blog/"},"pages":[{"title":"about","date":"2019-11-07T13:28:58.000Z","updated":"2019-11-23T12:04:24.425Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2019-11-07T13:28:19.000Z","updated":"2019-11-23T12:04:33.700Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"About me","date":"2019-11-09T08:49:56.000Z","updated":"2019-11-23T12:04:31.128Z","comments":true,"path":"about/me.html","permalink":"http://yoursite.com/about/me.html","excerpt":"","text":"我是谁？我在哪里？我在做什么？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2019-11-07T13:28:44.000Z","updated":"2019-11-23T12:03:00.122Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"2019的最后一个月","slug":"2019年的最后一个月","date":"2019-12-01T05:32:39.000Z","updated":"2019-12-01T07:55:24.849Z","comments":true,"path":"2019/12/01/2019年的最后一个月/","link":"","permalink":"http://yoursite.com/2019/12/01/2019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88/","excerpt":"","text":"💛今天，2019年12月01日，是 今年最后一个月的第一天。 🔺回想去年的12月，经历了很多，一切都是从 【晚安计划】的短信 开始。时至今天，我仍保存着去年的“晚安计划”短信。 💙今晚开始，又是新的一轮【晚安计划】。不知道你有没有呢？ 🧡从国庆回到学校后，课多了、要处理的事情多了，总之这两个月来搞的东西太多了。 💚不过呢，也是有收哦的哦！像比如，现在这个博客(2019.11.07)就是之一。还有自己写的小玩意，以后会放出来。 💜忙完这最后的12月，也该是时候让自己出去走走了。总是待在宿舍、教学楼，会傻的hh。 💛最近很想家，很想回家。不过也要等到2020元旦之后啦，也快了快了。 最后，祝我自己和大家12月健康、平安、快乐、好运…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Java—(递归+非递归)阶层","slug":"Java—（递归-非递归）阶层","date":"2019-11-30T08:08:51.000Z","updated":"2019-12-01T01:01:56.156Z","comments":true,"path":"2019/11/30/Java—（递归-非递归）阶层/","link":"","permalink":"http://yoursite.com/2019/11/30/Java%E2%80%94%EF%BC%88%E9%80%92%E5%BD%92-%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89%E9%98%B6%E5%B1%82/","excerpt":"递归阶层算法、非递归阶层算法 扩展①：求阶层的和 扩展②：寻找最高阶、打印阶层的计算过程","text":"递归阶层算法、非递归阶层算法 扩展①：求阶层的和 扩展②：寻找最高阶、打印阶层的计算过程 非递归阶层算法12345678910111213141516171819import java.util.Scanner;public class UnRecurrenceFactorial { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"input:\"); int n = sc.nextInt(); int a = 1; while(n != 1){ a = a*n; n--; } System.out.println(a); sc.close(); }} 递归阶层算法12345678910111213141516public class RecurrenceFactorial { public static void main(String[] args) { long fac = fac(k);//修改k的值即可 System.out.println(\"n的阶乘为:\" + fac); } public static long fac(int n){ if(n == 1){ return 1; }else{ return fac(n-1) * n; } }} 扩展①：求阶层的和🔺计算 1!+2!+3!+···+k! 的值： 123456789101112public static void main(String[] args) { int i,j; long sum = 0; for(i = 1; i &lt;= k; i++){ //修改k的值即可 int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } sum += t; } System.out.println(sum);} 扩展②：寻找最高阶、打印阶层的计算过程🔺题目： 指定一个整型数MAX，试编写一个程序求满足1!+2!+3!…+n!&lt;=MAX 的最大整数n。并把满足条件的求和式子和找到的最大整数n打印输出。 示例1：MAX=111时，输出 1!+2!+3!+4!=33 满足条件的最大整数:4 示例2：MAX=9876 1!+2!+3!+4!+5!+6!+7!=5,913 满足条件的最大整数:7 🔺代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class Du { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.println(\"the value of MAX:\"); int MAX; MAX=input.nextInt(); System.out.println(\"满足条件的最大整数：\"+SUM(MAX)); input.close(); } public static int SUM(int MAX) { int i = 0,j; long sum = 0; for(i = 1; i &lt;= 10; i++){ int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } sum += t; if(sum&gt;MAX) break; } Print(i-1); return i-1; } /*打印阶层的计算过程*/ public static void Print(int k) { int i,j; long sum = 0; for(i = 1; i &lt;= k; i++){ //修改k的值即可 int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } System.out.printf(\"%d! + \",i); sum += t; } System.out.print(\"\\b\\b= \"+ sum);//退两个，删去最后一个+ System.out.println(); }} 🔺截图： 我的文章、代码简单，这里有更详细文章，见大佬👉Java实现n阶阶乘的计算 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java—向下/上取整","slug":"Java—-向下-上取整","date":"2019-11-30T05:44:08.000Z","updated":"2019-12-01T00:58:39.448Z","comments":true,"path":"2019/11/30/Java—-向下-上取整/","link":"","permalink":"http://yoursite.com/2019/11/30/Java%E2%80%94-%E5%90%91%E4%B8%8B-%E4%B8%8A%E5%8F%96%E6%95%B4/","excerpt":"Java中对数的舍入也分有 向上舍入（向上取整） 向下舍入（向下取整） Java的Math类中包含数舍入的方法： ceil() floor() ceil()和floor() ceil() floor() 向上取整 向下取整 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 返回小于等于（&lt;=）给定参数的最大整数 。","text":"Java中对数的舍入也分有 向上舍入（向上取整） 向下舍入（向下取整） Java的Math类中包含数舍入的方法： ceil() floor() ceil()和floor() ceil() floor() 向上取整 向下取整 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 返回小于等于（&lt;=）给定参数的最大整数 。 看个栗子👇 关于Math类的说明，参考 Number &amp; Math 类方法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java—打印字母表","slug":"Java—打印字母表","date":"2019-11-30T03:46:31.000Z","updated":"2019-12-01T01:06:45.884Z","comments":true,"path":"2019/11/30/Java—打印字母表/","link":"","permalink":"http://yoursite.com/2019/11/30/Java%E2%80%94%E6%89%93%E5%8D%B0%E5%AD%97%E6%AF%8D%E8%A1%A8/","excerpt":"A到Z的ASCII码值是65到90 a到z的ASCII码值是97到122","text":"A到Z的ASCII码值是65到90 a到z的ASCII码值是97到122 Demo123456789101112131415161718public class AlphabetDemo { public static void main(String[] args) { /*char和int类型能够相互转换，相信大家都明白 */ //A到Z的ASCII码是65到90，a到z的ASCII码值是97到122 for (char c = 0; c &lt; 128; c++) { //java里包装类的一个静态方法，确定c是字母还是小写！！！） if (Character.isLowerCase(c)) { System.out.printf(\"value: %3d char: %c\\n\", (int)c, c); //同上，判断c是大写 } else if (Character.isUpperCase(c)) { System.out.printf(\"value: %3d char: %c\\n\", (int)c, c); } } } } 注：关于isLowerCase和isUpperCase在文末有进一步的说明。 扩展 ①🔺题目： 🔺参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Scanner;public class Alphabet { public static void main(String[] args) { Scanner input=new Scanner(System.in); int n,level; System.out.println(\"the value of n:\"); n=input.nextInt(); level=(int)Math.ceil(26/n);//向上取整 System.out.println(\"======Upper========\"); char CH=65; for(int i=0;i&lt;=level;i++) { for(int j=0;j&lt;n;j++) { System.out.printf(\"%c \",CH); ++CH; if(CH&gt;=90) break; } System.out.println(); } System.out.println(); System.out.println(\"======Lower========\"); char ch=97; for(int i=0;i&lt;=level;i++) { for(int j=0;j&lt;n;j++) { System.out.printf(\"%c \",ch); ++ch; if(ch&gt;=123) break; } System.out.println(); } System.out.println(); input.close(); }} 注意：Math.ceil();//向上取整 参考：我的另一篇博客：Java—向下/上取整 🔺执行截图： 扩展 ②上面常规思考题中的第6题是自左往右从上往下的水平顺序输出大写堆和小写堆字母表。假如想要按照自上而下从左往右的垂直顺序输出大写堆，该如何实现程序？ 即假如每列输出N=5个，则程序的输出情况如下： = = = Upper = = = A F K P U Z B G L Q V C H M R W D I N S X E J O T Y 试用一重循环编写程序，指定一个整型数N(1&lt;=N&lt;=26)，按示例规格输出列优先排序的大写字母表。 🔺代码： 123456789101112131415161718192021222324252627import java.util.Scanner;public class Aphabet { public static void main(String[] args) { System.out.println(\"======Upper========\"); Scanner input = new Scanner(System.in); int n,level; System.out.println(\"the value of n:\"); n = input.nextInt(); level = (int)Math.ceil(26/n);//向上取整 int j = 0; char ch = 65; p(1, n, ch); } public static void p(int x,int n,char ch) { if(x &gt; n) return; for(int i = x;i &lt;= 26;i += n){ ch = (char)(i + 64); System.out.print(ch + \" \"); } System.out.println(); ++x; p(x, n, ch); }} 下午做了半个多小时都没做出来，晚上玩了会游戏突然想到用递归，下午怎么就没想到呢？然后游戏就挂机被举报了，但一气呵成搞定了这题。说明思想不够灵活hhh 🔺截图： 补充：Java Character 类isLowerCase() 方法🔺作用：用于判断指定字符是否为小写字母。 🔺语法 1boolean isLowerCase(char ch) 🔺参数 ch – 要测试的字符。 🔺返回值 如果字符为小写，则返回 true；否则返回 false。 🔺实例 1234567public class Test { public static void main(String args[]) { System.out.println( Character.isLowerCase('a')); System.out.println( Character.isLowerCase('A')); }} 🔺以上程序执行结果为： 12truefalse isUpperCase() 方法 🔺作用：用于判断指定字符是否为大写字母。 🔺语法 1boolean isUpperCase(char ch) 🔺参数 ch – 要测试的字符。 🔺返回值 如果字符为大写，则返回 true；否则返回 false。 🔺实例 1234567public class Test { public static void main(String args[]) { System.out.println( Character.isUpperCase('b')); System.out.println( Character.isUpperCase('B')); }} 🔺以上程序执行结果为： 12falsetrue document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java—5种生成随机数的方法","slug":"Java—5种生成随机数的方法","date":"2019-11-30T02:33:25.000Z","updated":"2019-12-01T01:53:18.885Z","comments":true,"path":"2019/11/30/Java—5种生成随机数的方法/","link":"","permalink":"http://yoursite.com/2019/11/30/Java%E2%80%945%E7%A7%8D%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"5种生成随机数的简单方法 和一篇大佬的文章👇","text":"5种生成随机数的简单方法 和一篇大佬的文章👇 方法①🔺 通过java.Math包的random方法得到1-10的int随机数 🔺 公式： 最小值—最大值（整数）的随机数 (类型) 最小值+Math.random()*最大值 12345678910111213import java.util.Random;public class RandomDemo { public static void main(String[] args) { for (int i=0;i&lt;5;i++) { System.out.println((int)(1+Math.random()*10)); int k; k=(int)(1+Math.random()*10); } }} 方法②🔺借助java.util.Random类来产生一个随机数发生器，也是最常用的一种，构造函数有两个，Random()和Random(long seed)。第一个就是以当前时间为默认种子，第二个是以指定的种子值进行。产生之后，借助不同的语句产生不同类型的数。 🔺种子就是产生随机数的第一次使用值,机制是通过一个函数,将这个种子的值转化为随机数空间中的某一个点上,并且产生的随机数均匀的散布在空间中。以后产生的随机数都与前一个随机数有关 123456789101112131415import java.util.Random;public class RandomDemo { public static void main(String[] args) { Random r = new Random(); for(int i=0 ; i&lt;5 ; i++) { int ran1 = r.nextInt(100);//种子：100 System.out.println(ran1); } }} 注：类似的方法可参考 利用Random类来产生5个20~50之间的随机整数 方法③ 生成随机数需要使用到Java工具类中的Random类。 要求是随机x到y之间的整数，即指定范围，则使用Random类中的nextInt(int n)方法。 该方法生成从0（包括）到n（不包括）之间的随机整数，是一个伪随机数，并不是真正的随机数。 若x不为0，则需要在随机结果后加上x。参数n的值也需要加上1后减去x。最后结果才符合要求的范围。 1234567891011121314151617import java.util.Random;public class RandomDemo { public static final int START = 50; //定义范围开始数字 public static final int END = 99; //定义范围结束数字 public static void main(String[] args) { //创建Random类对象 Random random = new Random(); //产生随机数 int number = random.nextInt(END - START + 1) + START; //打印随机数 System.out.println(\"产生一个\"+START+\"到\"+END+\"之间的随机整数：\"+number); }} 注：更多方法可参考【Java工具类】—-产生随机数 方法④🔺 返回的数值是 [ 0.0 , 1.0 ) 的double型数值，由于double类数的精度很高，可以在一定程度下看做随机数，借助（int）来进行类型转换就可以得到整数随机数了 12345678public static void main(String[] args){ for (int i = 1; i &lt;= 10; i++) { int max=99,min=10;//生成两位随机正整数 int ran2 = (int) (Math.random()*(max-min)+min); System.out.println(ran2); }} 方法⑤🔺 返回从1970年1月1日0时0分0秒（这与OS有关）到现在的一个long型的毫秒数，取模之后即可得到所需范围内的随机数 12345678public static void main(String[] args) { int max=100,min=1; long randomNum = System.currentTimeMillis(); int ran3 = (int) (randomNum%(max-min)+min); System.out.println(ran3); } 大佬的文章这个大佬【peabits】的文章贼详细，可以好好琢磨琢磨 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java中的<<、>>和>>>","slug":"Java中的、-和","date":"2019-11-29T16:33:38.000Z","updated":"2019-11-29T17:14:55.054Z","comments":true,"path":"2019/11/30/Java中的、-和/","link":"","permalink":"http://yoursite.com/2019/11/30/Java%E4%B8%AD%E7%9A%84%E3%80%81-%E5%92%8C/","excerpt":"左移 左移运算符 &lt;&lt; 👉使指定值的所有位都左移规定的次数 左移m&lt;&lt;n，代表把数字m在无溢出的前提下乘以2的n次方 右移 右移运算符 &gt;&gt; 👉 使指定值的所有位都右移规定的次数 右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数 注意，如果是单数，也就是二进制末位为1，则结果是将m除以2的n次方的整数商 无符号右移 无符号右移运算符 &gt;&gt;&gt; 👉同右移，但是结果全变正数","text":"左移 左移运算符 &lt;&lt; 👉使指定值的所有位都左移规定的次数 左移m&lt;&lt;n，代表把数字m在无溢出的前提下乘以2的n次方 右移 右移运算符 &gt;&gt; 👉 使指定值的所有位都右移规定的次数 右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数 注意，如果是单数，也就是二进制末位为1，则结果是将m除以2的n次方的整数商 无符号右移 无符号右移运算符 &gt;&gt;&gt; 👉同右移，但是结果全变正数 Demo 栗子 以下内容转载于 Java中的&lt;&lt; 和 &gt;&gt; 和 &gt;&gt;&gt; 详细分析 详细分析&lt;&lt;表示左移，不分正负数，低位补0； 注：以下数据类型默认为byte-8位 左移时不管正负，低位补0 正数：r = 20 &lt;&lt; 2 20的二进制补码：0001 0100 向左移动两位后：0101 0000 结果：r = 80 负数：r = -20 &lt;&lt; 2 -20 的二进制原码 ：1001 0100 -20 的二进制反码 ：1110 1011 -20 的二进制补码 ：1110 1100 左移两位后的补码：1011 0000 反码：1010 1111 原码：1101 0000 结果：r = -80 &gt;&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1； 注：以下数据类型默认为byte-8位 正数：r = 20 &gt;&gt; 2 20的二进制补码：0001 0100 向右移动两位后：0000 0101 结果：r = 5 负数：r = -20 &gt;&gt; 2 -20 的二进制原码 ：1001 0100 -20 的二进制反码 ：1110 1011 -20 的二进制补码 ：1110 1100 右移两位后的补码：1111 1011 反码：1111 1010 原码：1000 0101 结果：r = -5 &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0 正数： r = 20 &gt;&gt;&gt; 2 的结果与 r = 20 &gt;&gt; 2 相同； 负数： r = -20 &gt;&gt;&gt; 2 注：以下数据类型默认为int 32位 -20:源码：10000000 00000000 00000000 00010100 反码：11111111 11111111 11111111 11101011 补码：11111111 11111111 11111111 11101100 右移：00111111 11111111 11111111 11111011 结果：r = 1073741819 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java用最有效率的方法计算2乘以8","slug":"Java—用最有效率的方法计算2乘以8","date":"2019-11-29T16:24:00.000Z","updated":"2019-12-01T01:58:23.398Z","comments":true,"path":"2019/11/30/Java—用最有效率的方法计算2乘以8/","link":"","permalink":"http://yoursite.com/2019/11/30/Java%E2%80%94%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%972%E4%B9%98%E4%BB%A58/","excerpt":"","text":"最有效率的方法 👉 2 &lt;&lt; 3 其中，左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方 再比如，31 * num 等价于( num &lt;&lt; 5 ) – num 左移5位相当于乘以2的5次方（32），再减去自身（-1），这一过程就相当于乘以31 注：关于移位运算符，可参考我的下一篇博客 Java中的&lt;&lt;、&gt;&gt;和&gt;&gt;&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—static关键字","slug":"Java笔记—static关键字","date":"2019-11-28T09:24:41.000Z","updated":"2019-11-29T17:43:43.410Z","comments":true,"path":"2019/11/28/Java笔记—static关键字/","link":"","permalink":"http://yoursite.com/2019/11/28/Java%E7%AC%94%E8%AE%B0%E2%80%94static%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"static 关键字修饰目标 (成员数据/方法/成员内部类/代码块)属于类的 静态类 静态块 静态方法 静态变量 static 成员内部类 static 代码块 static 成员方法 static 成员变量 直接通过类就可以访问。所有对象共享该类 只能出现在类中不能出现方法体中，类加载后初始化时被执行一次。注意:区分构造代码块，每次构造都被执行 直接通过类就可以调用。不用等创建了实例后 类加载时在Java方法区分配空间，所有对象共享 区别：无static关键字成员属于具体的对象实例： 实例变量、实例方法(只能通过对象调用)、实例成员内部类(只能通过对象引用) static 成员的访问格式一般要通过 *“ 类名 ” *来访问 静态变量 静态方法 静态成员内部类 类名 . 静态变量 类名 . 静态方法 类名 . 静态成员内部类 注意两点： 🔺 static成员方法/代码块：方法体 只能 使用静态成员变量(或内部类)或调用静态方法。（老师称： 静者恒静） 🔺 static成员方法/代码块：方法体中不能出现this(当前对象)或super(基类对象)","text":"static 关键字修饰目标 (成员数据/方法/成员内部类/代码块)属于类的 静态类 静态块 静态方法 静态变量 static 成员内部类 static 代码块 static 成员方法 static 成员变量 直接通过类就可以访问。所有对象共享该类 只能出现在类中不能出现方法体中，类加载后初始化时被执行一次。注意:区分构造代码块，每次构造都被执行 直接通过类就可以调用。不用等创建了实例后 类加载时在Java方法区分配空间，所有对象共享 区别：无static关键字成员属于具体的对象实例： 实例变量、实例方法(只能通过对象调用)、实例成员内部类(只能通过对象引用) static 成员的访问格式一般要通过 *“ 类名 ” *来访问 静态变量 静态方法 静态成员内部类 类名 . 静态变量 类名 . 静态方法 类名 . 静态成员内部类 注意两点： 🔺 static成员方法/代码块：方法体 只能 使用静态成员变量(或内部类)或调用静态方法。（老师称： 静者恒静） 🔺 static成员方法/代码块：方法体中不能出现this(当前对象)或super(基类对象) Demo：类内使用1234567891011121314151617181920212223import static java.lang.System.*; //静态导入静态方法或对象 public class StaticDemo1 { static int a = 3, b, i = 0; // 静态变量 char ch = 'Y'; // 实例变量 static void meth(int x) { // 静态方法 out.println(\"x = \" + x); //out.println(\"ch = \" + ch);//【1】Error! } static { // 静态代码块-类加载时只执行1次 out.println(\"静态块初始化：仅1次\"); b = a * 4; //out.println(\"ch = \" + ch);//【1】Error! } public static void main(String[] args) { meth(42); //静态方法调用静态方法 new StaticDemo1(); //创建匿名对象1 new StaticDemo1(); //创建匿名对象2 } { out.println(\"ch = \" + ch);//【2】OK! out.printf(\"构造代码块：第%d次构造第%1$d次执行\\n\", (++i)); } }} 注意： 🔺特别注意：类的静态代码块仅在类在加载后初始化时被执行1次 🔺第一次new一个类时才加载该类 🔺静态方法、静态块不能访问非静态的成员（即，静者恒静）。如上述代码中的注释【1】 🔺静态块初始化：仅1次 Demo：类外使用和静态块执行时机1234567891011121314151617181920212223import static java.lang.System.out;class MyD{ private static int m; public static int n; static{ // 静态代码块【2】 m = n = 0; out.println(\"仅1次\"); } public static void callMe(){ out.printf(\"m=%d,n=%d\", m, n); }}public class StaticDemo2 { public static void main(String[] args) { MyD d; //【0】MyD被加载，但未主动使用 d = new MyD(); //【1】这里才【主动使用】MyD，于是执行其静态代码块【2】 MyD.n++; //最佳：类名.静态变量 MyD.callMe(); //最佳：类名.静态方法 }} 特别留意： 🔺用一个类声明一个类对象变量，至多会加载该类，但还未主动使用🔺老师说：【主动使用】，是一个比较高级的专题，暂不深入 注：前面的几篇Java笔记中也有提到static，后来上课老师再小结static关键词，结合前面的笔记食用效果更佳。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—this关键字","slug":"Java笔记—this关键字","date":"2019-11-28T09:11:18.000Z","updated":"2019-11-29T17:36:57.692Z","comments":true,"path":"2019/11/28/Java笔记—this关键字/","link":"","permalink":"http://yoursite.com/2019/11/28/Java%E7%AC%94%E8%AE%B0%E2%80%94this%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"this 关键字三个形式上的用途，但本质上就两个： 调用重载的其他构造方法：放置在构造方法体首行的this()或this(实参列表) 作为当前对象，引用成员（数据、方法等）：区分同名变量等 作为当前对象，方法返回当前对象的引用，形成链式调用","text":"this 关键字三个形式上的用途，但本质上就两个： 调用重载的其他构造方法：放置在构造方法体首行的this()或this(实参列表) 作为当前对象，引用成员（数据、方法等）：区分同名变量等 作为当前对象，方法返回当前对象的引用，形成链式调用 案 例 ： 123456789101112131415161718192021222324252627282930313233public class ThisDemo { private int a = 1; private String name = \"good\"; private int i = 0; public ThisDemo(){ System.out.println(\"无参构造子\" + this); } public ThisDemo(int a, String name){ this(); // 【1】调用无参构造子 this.a = a; // 【2】当前对象，引用成员 this.name = name; } public ThisDemo setA(int a){ this.a = a; return this; // 【3】返回当前对象 } public ThisDemo setName(String name){ this.name = name; return this; } public ThisDemo inc(){ i++; return this; } public static void main(String[] args) { ThisDemo t1 = new ThisDemo(); t1.setA(100).setName(\"guo\").inc().inc(); System.out.println(t1.i); ThisDemo t2 = new ThisDemo(2, \"Tom\"); t2.inc().setA(8).inc().inc(); //【4】链式调用 System.out.println(t2.i); }} 特别注意，案例中的【3】和【4】。 注：前面的几篇Java笔记中也有提到this，后来上课老师再小结this关键词，结合前面的笔记食用效果更佳。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"对SQL的触发器的浅理解","slug":"浅谈SQLServer触发器","date":"2019-11-26T05:08:18.000Z","updated":"2019-11-28T11:22:43.203Z","comments":true,"path":"2019/11/26/浅谈SQLServer触发器/","link":"","permalink":"http://yoursite.com/2019/11/26/%E6%B5%85%E8%B0%88SQLServer%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"个人理解如果需要做一些特定的增删改操作，就可以使用触发器。 触发 ，当做了某种预设的操作时才会执行触发器的命令。 栗子：假设现在有个员工基础信息表，里面有员工的身份证号码，手机等基本信息。那么，当你换了身份证或手机，需要修改号码的时候，肯定是去修改员工的基础资料表。假设你现在有别的地方，比如人事档案啊之类的，同样使用了员工的手机等信息，难道还要再去修改一次档案表么？那么如果还有其他地方使用了呢？而在这种时候有触发器就好解决了。如果设置一个触发器来判断，如果修改了基础表的信息，那么就同步把其他使用了基础表的关联信息也更改成最新的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"SQL Server","slug":"SQL-Server","permalink":"http://yoursite.com/tags/SQL-Server/"}]},{"title":"G.E.M.邓紫棋《句号》MV首播！","slug":"G.E.M.邓紫棋《句号》MV首播！","date":"2019-11-25T14:21:12.000Z","updated":"2019-11-29T04:53:27.657Z","comments":true,"path":"2019/11/25/G.E.M.邓紫棋《句号》MV首播！/","link":"","permalink":"http://yoursite.com/2019/11/25/G.E.M.%E9%82%93%E7%B4%AB%E6%A3%8B%E3%80%8A%E5%8F%A5%E5%8F%B7%E3%80%8BMV%E9%A6%96%E6%92%AD%EF%BC%81/","excerpt":"G.E.M.邓紫棋《句号》MV首播！ 🧡点击破亿『全创作天后』G.E.M.邓紫棋和过去告别，向未来大步迈开，开启音乐版图新起点的一个“句号”。 这是华语乐坛前所未见的真实披露之作，她用&lt;句号&gt;这首歌，预告了全新的音乐篇章，翻页之后，就要开始。 榜单Top 1 💗邓紫棋新歌《句号》上线颇有波折，国内几大音乐平台推迟上线，但在唯一上线的Apple Music平台，已经超过霉霉新歌《lover》，一举拿下 榜单 Top1！ 官方MV视频第一发布于微博： GEM鄧紫棋 2019.11.28更换 1 网页视频源： B站官方合作发布","text":"G.E.M.邓紫棋《句号》MV首播！ 🧡点击破亿『全创作天后』G.E.M.邓紫棋和过去告别，向未来大步迈开，开启音乐版图新起点的一个“句号”。 这是华语乐坛前所未见的真实披露之作，她用&lt;句号&gt;这首歌，预告了全新的音乐篇章，翻页之后，就要开始。 榜单Top 1 💗邓紫棋新歌《句号》上线颇有波折，国内几大音乐平台推迟上线，但在唯一上线的Apple Music平台，已经超过霉霉新歌《lover》，一举拿下 榜单 Top1！ 官方MV视频第一发布于微博： GEM鄧紫棋 2019.11.28更换 1 网页视频源： B站官方合作发布 ( ͡° ͜ʖ ͡°)✧我已经 循环 MV几天了，等待网易云上架。 听说 “连Siri都被圈粉？有网友发现现在向Siri提出“播放世界第一的歌曲”，结果直接是《句号》” 有iPhone的，赶紧试试看吧 ( ͡° ͜ʖ ͡°)✧ @芒果捞小白.png 1.第一次发这篇文章的第二天发现视频链接失效，研究了一下，发现微博视频用的是临时链接，就是生命周期只有1天的临时链接，于是我改由B站的视频 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"音乐","slug":"音乐","permalink":"http://yoursite.com/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"Java笔记—包","slug":"Java笔记—包","date":"2019-11-23T05:54:59.000Z","updated":"2019-11-29T17:36:24.562Z","comments":true,"path":"2019/11/23/Java笔记—包/","link":"","permalink":"http://yoursite.com/2019/11/23/Java%E7%AC%94%E8%AE%B0%E2%80%94%E5%8C%85/","excerpt":"Java笔记——包创建时间：2019.11.23 说明：持续更新ing 概念 包(package) 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 ✔ 用来组织和管理类、接口、枚举和注解✔ 有三方面作用：1)便于组织,比如按功能、按团队等；2)解决命名冲突；3)进行访问权限控制(同包可用，包外不可见等) 如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。","text":"Java笔记——包创建时间：2019.11.23 说明：持续更新ing 概念 包(package) 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 ✔ 用来组织和管理类、接口、枚举和注解✔ 有三方面作用：1)便于组织,比如按功能、按团队等；2)解决命名冲突；3)进行访问权限控制(同包可用，包外不可见等) 如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。 作用 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 🔺 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 同一个包中类名字是不同的，不同包中类的名字可以相同，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 语法格式 123package 包名或package 父包名[.子包名][.孙包名][.层次下去] 🔸包名符合标识符命名规范，一般由小写字母组成🔹必须出现在源文件的第一行(忽略注释语句)🔸每个源文件至多只能出现一个package语句🔹如果没有package语句，那就使用无名包(或称默认包:所在的当前目录)🔸包的背后对应着操作系统的路径名称 示例： 12345678910111213package ch08.web.sample; public class Person { String name; int age; //省略部分代码 } class Dog { String name; int age; //省略部分代码} 🔺package ch08.web.sample; 这个层级的文件夹必须先存在：即ch08/web/sample 包的使用 🔺import 关键字 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。 为了使用另外一个包中的成员(主要是类)，可以明确import该成员。 避免重复使用完整路径的类名。 语法格式： 1import package1[.package2…].(classname|*); 注意： 必须紧跟在package语句之后(若有的话，若无package，则import出现在源文件头部)。 可以使用 * 来表示导入当前一层包中的所有类。但是* 不可以连续使用。 1import java.*.*; // Error! 不表示可以继续导入当前包的子包。如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 Java常用包 🔵JavaAPI的类库也是按照包的方式组织的 包名 描述 备注 Java.lang Java语言进行程序设计的基础类(核心类库)，它是默认导入的包 Runnable接口和Object、Math、String、StringBuffer、System、Thread、Throwable类 Java.util 实用工具类包 定义系统特性、随机数、日期时间、日历、集合类等 Java.io IO类包 包含能提供多种输入输出的文件读写类 Java.net 网络编程API Java.sql 数据库操作包 Java.text 文本处理相关类 包含了一些用来处理文本、数字和消息的类和接口 Java.awt 提供创建界面和绘制图形图像的所有类 Javax.asing awt上封装的GUI包 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"推荐3款文本编辑器","slug":"文本编辑器","date":"2019-11-22T02:34:04.000Z","updated":"2019-11-29T17:38:00.468Z","comments":true,"path":"2019/11/22/文本编辑器/","link":"","permalink":"http://yoursite.com/2019/11/22/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"前言今天作者推荐两款文本编辑器。 我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。 这里作者就只推荐Notepad 3、Sublime和Atom。 关于VS Code和Vim，文末有两篇教程供大家入手。","text":"前言今天作者推荐两款文本编辑器。 我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。 这里作者就只推荐Notepad 3、Sublime和Atom。 关于VS Code和Vim，文末有两篇教程供大家入手。 //截断文章 Notepad 3 虽然 Windows 操作系统在过去几年中有了显著变化，但是，默认的 Windows 记事本却鲜有更新。如果您需要一个简单且适于编程的文本编辑器，Notepad3 将是一个不错的选择！ Notepad3是一款轻便快捷的基于 Scintilla 的文本编辑器，具有语法高亮、代码折叠、括号匹配、自动缩进、编码转换、换行格式转换、多次撤销或重做、书签、基于正则表达式的查找和替换等实用功能。它占用的内存很小，但功能强大，足以处理大多数编程工作。 Notepad 3 的界面 可能 是我见过所有主流文本编辑器里最最最简单清爽的吧？ 蓝奏云：下载链接（作者提供了已经汉化过的便携版本） （注意：Notepad 3和Notepad++没有关系 ） Sublime官方的介绍简单又粗暴 一款用于代码、标记和散文的精致文本编辑器 Sublime支持 Windows 、Mac 平台。插件是程序员的灵魂，Sublime不失这点。类似于 Eclipse，IDEA，它有着丰富的插件系统，完全可以满足各种开发编辑需求。 在这里插入图片描述 1）安装 官网关于Sublime的介绍语下就是win版的下载入口或者点击这里快速下载最新版==Sublime Text 3 (Build 3207)== 在这里插入图片描述 下载得到的是exe，双击开始安装。 在这里插入图片描述 安装导向界面，点击【Next】继续安装。 在这里插入图片描述 选择Sublime Text 3安装位置，您可以点击【Next】，软件会自动安装。或者您可以单击【Browse】，在弹出的安装位置窗口中，您可以自己选择Sublime Text安装位置，选择完成后点击【Next】。 在这里插入图片描述 这里可选择 添加到资源管理器上下文菜单 。 在这里插入图片描述 安装完后可以在桌面或者开始菜单中找到Sublime。 2）使用Sublime的界面特别简洁，让人看着很舒服。 在这里插入图片描述 这里，作者已经汉化过了。初始语言是English。 3）汉化 sublime 的插件的强大之处，sublime 通过 package control来统一管理安装的插件。现版本sublime 3自带package control功能。 将English变成Chinese，也可以通过Sublime的插件实现。 作者已经汉化过。为了教程，故在win7虚拟机上教大家如何实现汉化。 官网下载，并安装好, 刚安装好的是没有 Package Control 选项 在这里插入图片描述 找到 Tools-&gt;Install Package Control 选项，即可调出 Package Contro 不能直接找到 Install Package Control，去找“Tools-&gt;Command Palette…”选项 输入 ipc ,点击 Install Package Control，即可调出 Package Control 在这里插入图片描述 等待完成 在这里插入图片描述 找到 Preferences-&gt;Package Control 在这里插入图片描述 选项弹出命令行输入框，输入ip，点击“install Package 在这里插入图片描述 弹出命令行输入框，输入clz，点击“ChineseLocalizations” 在这里插入图片描述 搞定，设置成中文了 在这里插入图片描述 开开心心地食用汉化地Sublime吧 o(￣▽￣)o Atom Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。 官网在这里👈 在这里插入图片描述 友情链接：w3school之Atom教程Atom 中文社区 1）安装 在这里插入图片描述 官网地Downloa或者点击这里快速下载最新版==Atom (1.41.0)== 在这里插入图片描述 下载得到exe，双击开始安装。安装过程很简单，直接省略。 2）使用Atom 的界面也比较简洁。Atom提供了侧栏、标签栏，可提高效率。Atom还能链接到GitHub，这真是GitHub用户的福利。(当然，Atom本来就是Github推出的hhhh) 在这里插入图片描述 3）汉化Atom的汉化有两种方法： 方法一 打开软件后，点击 File&gt; Settings&gt; install 在这里插入图片描述 搜索 chinese，安装两个插件 在这里插入图片描述 重启软件 在这里插入图片描述 因为插件托管在国外，可能因为网速原因，会非常慢，因此推荐下载中文插件包，请看方法二👇 方法二 打开https://atom.io/packages/去官网下载中文包，搜索【Chinese】，找到【atom-simplified-chinese-menu】点击进入主页（如上图），然后再点【Verions】，之后，找到最新版本，点【zip】包下载即可。。作者在这已经准备好中文包了，点击这里下载 在这里插入图片描述 将下载好了的压缩包解压到 C:/user/&lt;用户名&gt;/.atom/packages/目录下面 在这里插入图片描述 打开Atom，发现已经Chinese了。 在这里插入图片描述 综上主流的文本编辑器有很多。每个人的需求不一样，找到合适自己的才是好的。Notepad 3、Sublime、Atom、VS Code、Vim、Notepad++（前段时间闹事，作者不方便再提） VS Code：传送门 Vim：传送门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java笔记—继承","slug":"Java笔记—继承","date":"2019-11-21T09:54:59.000Z","updated":"2019-11-29T17:36:14.410Z","comments":true,"path":"2019/11/21/Java笔记—继承/","link":"","permalink":"http://yoursite.com/2019/11/21/Java%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%A7%E6%89%BF/","excerpt":"Java笔记——继承 创建时间：2019.11.21 说明：持续更新ing 继承源于自然 就比如：兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 子类会具有父类的一般特性也会具有自身的特性。","text":"Java笔记——继承 创建时间：2019.11.21 说明：持续更新ing 继承源于自然 就比如：兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 子类会具有父类的一般特性也会具有自身的特性。 //截断文章 概念、目的、本质、特性 概念 它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 其主要作用在于，在已有基础上继续进行功能的扩充。（即，以存在的类为基础定义新的类，新类即拥有基类的数据成员和成员方法） 目的 继承的目的是代码重用 本质 描述了自然界中广泛存在的一种关系——类属关系（is-a），对应还有一种has-a关系即组合（聚合）关系。 特性 Java 继承的特性 子类拥有父类非private的属性，方法 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展 子类可以用自己的方式实现父类的方法 Java的继承是单继承，【但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性】 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系） 继承的关键字 继承可以使用 extends(单继承) 和 implements（变相的多继承）， 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 （1）extends关键字 Java只支持单继承，即：一个子类只能有一个父类.但可以有多个间接祖先类。 语法格式： 123456权限修饰符 class 父类名 { //父类体}权限修饰符 class 子类名 extends 父类名 { //子类体} 实例： 123456789101112public class Animal { private String name; private int id; public Animal(String myName, String myid) { //初始化属性值 } public void eat() { //吃东西方法的具体实现 } public void sleep() { //睡觉方法的具体实现 } } public class Penguin extends Animal{ } —————————————————————— 我 是 分 割 线 ——————————————————————— （2）implements关键字 变相地使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 public interface A { public void eat(); public void sleep(); } public interface B { public void show(); } public class C implements A,B { } &lt;!--￼2--&gt; 执行结果： &lt;!--￼3--&gt; —————————————————————— 我 是 分 割 线 ——————————————————————— （4）this关键字 指向”自己的引用“。 实例： 123456789101112131415161718192021222324class Animal { void eat() { System.out.println(\"animal : eat\"); }} class Dog extends Animal { void eat() { System.out.println(\"dog : eat\"); } void eatTest() { this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 }} public class Test { public static void main(String[] args) { Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); }} 输出结果： 123animal : eatdog : eatanimal : eat ——————————————————————————— 我 是 分 割 线 ———————————————————————————— （5）final关键字 声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。 继承类型 Java 不支持多继承，但支持多重继承 （ 一般不会超过三层 ）。 继承类型 继承的限制 🔺 Java只允许单继承、不允许多继承（一个子类继承一个父类）。 🔺 子类对象在进行实例化前首先调用父类构造方法，再调用子类构造方法实例化子类对象。 🔺 在继承时，子类会继承父类的所有结构。 在进行继承的时候，子类会继承父类的所有结构（包括私有属性、构造方法、普通方法）显示继承：所有非私有操作属于显示继承（可以直接调用）。隐式继承：所有私有操作属于隐式继承（不可以直接调用，需要通过其它形式调用（get或者set））。 子类能够使用的是所有非private操作，而所有的private操作无法被直接使用，所以称为隐式继承。 继承中“域的隐藏” 在子类中重新定义( 同 名 )继承自父类的域. 🔺子类继承父类非私域。 🔺子类定义与从父类继承下来的同名域，在子类中用该名直接访问就只能访问到子类定义的域，即隐藏了同名的继承下来的父类域。 🔺如果要访问同名父类域：通过父类方法，或者使用“*super . *” 实例： 123456789101112131415161718192021222324import static java.lang.System.*;class Super{ private int v1 = 1; int v2 = 2; public int getV1() { return v1; }}class Sub extends Super{ int v1 = 11; int v2 = 22; public void show() { out.println(v1); //out.println(super.v1); out.println(getV1()); out.println(v2); out.println(super.v2); }}public class FHTest{ public static void main(String[] args) { new Sub().show(); }} 继承情况的构造 首先🔺类初始化时,继承链上(包括当前类)的全部静态代码块最先执行一次。之后不再执行，除非程序又重启。(按链序和声明序且仅1次) 其次🔺创建子类实例时,会先进行父类的构造(要么显式进行，要么隐式用super()进行) 最后🔺类的构造顺序：构造代码块(按声明序) ➡ 构造方法 总体🔺父类静态块 ➡ 子类静态块 ➡ 父类构造块 ➡ 父类构造子 ➡ 子类构造块 ➡ 子类构造子（下划线”__”部分， 仅执行一次） 总结 1、为什么使用继承 从已有的类派生出新的类，称为继承。 在不同的类中也可能会有共同的特征和动作，可以把这些共同的特征和动作放在一个类中，让其它类共享。 因此可以定义一个通用类，然后将其扩展为其它多个特定类，这些特定类继承通用类中的特征和动作。 继承是 Java 中实现软件重用的重要手段，避免重复，易于维护，易于理解。 2、父类和子类 如果类 B 从类 A 派生，或者说类 B 扩展自类 A，或者说类 B 继承类 A， 则称类 A 为”父类”，也称为超类、基类； 称类 B 为”子类”，也称为次类、扩展类、派生类。 子类从它的父类中继承可访问的数据域和方法，也可以添加新的数据域和新的方法。 定义继承的语法： 1修饰符 class 子类名 extends 父类名 例如：Shape 类是父类，其子类可以有 Circle 类、Rectangle 类、Triangle 类，等等。 继承的注意点： 子类不是父类的子集，子类一般比父类包含更多的数据域和方法。 父类中的 private 数据域在子类中是不可见的，因此在子类中不能直接使用它们。 继承是为”是一个”的关系建模的，父类和其子类间必须存在”是一个”的关系，否则不能用继承。 但也并不是所有”是一个”的关系都应该用继承。例如，正方形是一个矩形，但不能让 Square 类来继承 Rectangle 类，因为正方形不能从矩形扩展得到任何东西。正确的继承关系是 Square 类继承 Shape 类 Java 只允许单一继承（即一个子类只能有一个直接父类），C++ 可以多重继承（即一个子类有多个直接父类）。 3、super 关键字 super 表示使用它的类的父类。super 可用于： 调用父类的构造方法； 调用父类的方法（子类覆盖了父类的方法时）； 访问父类的数据域（可以这样用但没有必要这样用）。 调用父类的构造方法语法： 12345super(); 或 super(参数列表); 注意：super 语句必须是子类构造方法的第一条语句。不能在子类中使用父类构造方法名来调用父类构造方法。 父类的构造方法不被子类继承。调用父类的构造方法的唯一途径是使用 super 关键字，如果子类中没显式调用，则编译器自动将 super(); 作为子类构造方法的第一条语句。这会形成一个构造方法链。 静态方法中不能使用 super 关键字。 调用父类的方法语法： 1super.方法名(参数列表); 如果是继承的方法，是没有必要使用 super 来调用，直接即可调用。但如果子类覆盖或重写了父类的方法，则只有使用 super 才能在子类中调用父类中的被重写的方法。 4、this 关键字 this 关键字表示当前对象。可用于： 调用当前类的构造方法，并且必须是方法的第一条语句。如：this(); 调用默认构造方法。this(参数); 调用带参构造方法。 限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 this.num = num。this.num 表示当前对象的数据域变量 num，而 num 表示方法中的局部变量。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—数组","slug":"Java笔记—数组","date":"2019-11-20T04:54:46.000Z","updated":"2019-11-29T17:36:21.566Z","comments":true,"path":"2019/11/20/Java笔记—数组/","link":"","permalink":"http://yoursite.com/2019/11/20/Java%E7%AC%94%E8%AE%B0%E2%80%94%E6%95%B0%E7%BB%84/","excerpt":"Java笔记——数组创建时间：2019.11.20 说明：持续更新ing ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 数组 数组是一组相同类型的变量（元素）的集合。可以用来存放一组相同类型的数据。数组的学习涉及数组的定义、赋值和使用。再扩展一点就是二维数组的应用。数组既是一种重要的数据类型，也是一种重要的数据结构。 数组（array）————一组相同类型的变量(元素)集合 相同的任意类型 (包括基本类型、类类型等) 这组变量被连续地存放在Java堆区的内存空间 数组是一种引用类型，数组名是一个地址的别名 数组需要创建（new），否则不会被分配堆空间 数组名对应的地址单元中存放上述连续堆区空间的首地址 🔺 对程序员而言, 数组总体有三样东西：数组名+数组长度+数组元素","text":"Java笔记——数组创建时间：2019.11.20 说明：持续更新ing ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 数组 数组是一组相同类型的变量（元素）的集合。可以用来存放一组相同类型的数据。数组的学习涉及数组的定义、赋值和使用。再扩展一点就是二维数组的应用。数组既是一种重要的数据类型，也是一种重要的数据结构。 数组（array）————一组相同类型的变量(元素)集合 相同的任意类型 (包括基本类型、类类型等) 这组变量被连续地存放在Java堆区的内存空间 数组是一种引用类型，数组名是一个地址的别名 数组需要创建（new），否则不会被分配堆空间 数组名对应的地址单元中存放上述连续堆区空间的首地址 🔺 对程序员而言, 数组总体有三样东西：数组名+数组长度+数组元素 “声明、创建、初始化、访问”数组 声明数组： 🔺只给数组变量(由数组名描述)分配空间，而不会给数组按要存放的元素的多少来分配空间。 有两种形式——&gt;推荐第一种： 数据类型[] 数组名 12345//数据类型[] 数组名int[] a;//数据类型 数组名[]int a[]; ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 创建数组：用new运算符，同对象的创建。 有两种形式——&gt; 123456//先声明，后创建int[] a; //声明存放int型数据的数组aa = new int[10]; //在Java堆区中创建10个int型元素空间(共40个字节)//声明和创建合一int[] test = new int[12]; 注意： 🔺声明数组，仅仅创建数组变量🔺创建数组，才在堆区中分配空间 [ ]中必须是非负整数，否则执行时异常。可以是字面常量、也可以是变量，只要保证其值是非负整数。 创建数组之后，各元素的默认初始值是：数值型为0(0.0)；字符型’\\0’；引用类型null；布尔型false ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 初始化数组：在创建好的数组元素空间中存放初始值.否则按默认值初始化。 🔺数组创建时（即new时使用）初始化器语法：{元素值列表}。 12//声明存放int型数据的数组aMonth并初始化int[] aMonth = new int[]{1,2,3,4,5,6,7,8,9,10,11,12}; 注意： 使用了初始化器之后不能显式指定长度 即 new int[12]{…} ，不对 12345int[] a; //先声明数组aa = new int[2]{1,2}; // Error,不能显式指明长度[2]a = {1,2}; // Errora = new int[]{1,2}; // OK!int[] b = {1, 2}; // OK!此方式用得最多 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 访问数组： 🔺数组元素：数组中的每一个变量，也被称为下标变量，索引变量 🔺下标从0开始：用[ ]运算符访问元素，即 数组名 [ 数组下标 ] 🔺既然是变量，所以数组元素可以作为左值也可以作为右值，比如a[i]++、b[0]=5;、a=b[0]+2;等等。 数组长度属性 🔺数组唯一的一个 只读 属性：length 存有数组元素个数值。 🔺*数组名.length * 遍历数组 🔺增强版for语句：foreach语句（JDK5开始提供） 🔺适用于遍历数组、集合元素等形式 123for(元素的数据类型 遍历变量x : 遍历对象obj){ //x是自定义遍历变量名 引用了x的Java语句; //循环体 } 注意： foreach语句是for的简化,任何foreach语句都可以改用for语句，反之不行。 foreach语句不关注下标。 用foreach的遍历变量不能修改元素值。 123456789public class Demo { public static void main(String[] args) { int[] a = {1, 3, 4, 5, 6, 8, 10}; /* 循环输出a */ for(int n : a){ // 利用变量n遍历数组a System.out.printf(\"%4d \", n); // n表示数组a的每一个元素值 } } } 二维数组、多维数组 image.png image.png image.png image.png Arrays 类 主要功能： 🔺java.util.Arrays类： 数组操作实用类,它提供了一系列静态方法 equals()方法:比较两个数组长度是否相同和对应索引上的元素值是否相同. fill()方法:向数组中填充数据. copyOf()方法:复制一个数组的部分元素并生成一个新的数组返回 sort()方法:若是基本类型则把数组元素按自然顺序升序排列.若是引用类型,其该实现了Comparable接口才能调用sort方法,否则报异常. binarySearch()方法:对已排序数组使用二分查找算法查找指定元素. asList()方法:返回数组的List对象形式. toString()方法:返回包含所有元素信息的字符串 parallelSort()方法:开启多线程的排序. deepEquals()方法:深度比较两个数组是否相同.适于任何深度的多维(嵌套)数组. 问：数组可以作为方法的参数或返回值吗？ 当然是可以的 。答案来源 m博客 数组作为方法参数 🔺数组作为方法参数传递，传递的参数是数组内存的地址。 123456789101112public static void main(String[] args) { int[] arr = {11, 22, 33, 44, 55}; System.out.println(\"1位置: \" + arr); printArray(arr); // 数组作为方法参数传递，传递的参数是数组内存的地址}public static void printArray(int[] arr) { System.out.println(\"2位置: \" + arr); for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); }}1234567891011 在这里插入图片描述 数组作为方法返回值 🔺数组作为方法的返回值，返回的是数组的内存地址。 123456789101112131415161718public static void main(String[] args) { //调用方法，接收数组的返回值 //接收到的是数组的内存地址 int[] arr = getArray(); for (int i = 0; i &lt; arr.length; i++) {System.out.println(arr[i]); }}/* 创建方法，返回值是数组类型 return返回数组的地址*/public static int[] getArray() { int[] arr = { 1, 3, 5, 7, 9 }; //返回数组的地址，返回到调用者 return arr;}1234567891011121314151617 在这里插入图片描述 该博主的延伸阅读： Java–数组的定义和访问、Java–数组原理内存图、Java–数组的常见操作 判断： Java中数组可以动态改变长度？ 错误。 Java中的数组的定义就是相同类型，固定长度的一组数据，一旦被初始化，长度不可更改。 10. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"教会你怎么安装和使用 Visio 哦 ~ ~","slug":"Visio教程","date":"2019-11-19T01:34:04.000Z","updated":"2019-11-29T17:38:35.080Z","comments":true,"path":"2019/11/19/Visio教程/","link":"","permalink":"http://yoursite.com/2019/11/19/Visio%E6%95%99%E7%A8%8B/","excerpt":"前言 很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。但是很多学生不会使用Visio，甚至不会安装Visio。 &gt; Visio 这么好的工具，一定要会用。 今天，作者写一份教程，教会大家了解如何安装和使用 ==Visio==。 在正式教程之前，我们先介绍 Visio。 Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。 &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。","text":"前言 很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。但是很多学生不会使用Visio，甚至不会安装Visio。 &gt; Visio 这么好的工具，一定要会用。 今天，作者写一份教程，教会大家了解如何安装和使用 ==Visio==。 在正式教程之前，我们先介绍 Visio。 Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。 &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。 //截断文章 安装1. 【下载资源】 网上也有很多资源，但是包是不完整的。版本也很多，要激活也不容易。 作者在这里已经打包好“Visio 2019”和“激活工具”了，点击这里(提取码: rwtr)开始下载。 由于现在的笔记本都是预装win10的，所以不用担心Visio 2019合不合适。毕竟Visio 2019在win7上是安装不了的。2. 【解压】 下载得到压缩包，解压，打开文件夹。 image.png 3. 【打开Setup】 打开“Visio 2019”，右键“Setup”选中“以管理员身份运行”。（似乎不用管理员也行？？？） 4. 【正在安装】 等待就好，很快的。 UTOOLS1574501447151.png 5. 【安装完成】 安装结束，点击“关闭”。 6. 【激活】 Visio 2019是==必须激活==才可以使用的。 否则，会一直弹窗提示激活的。 激活工具在另一个文件夹里。 补充一些关于KMS： KMS（全称:Key Management Service），这个是微软的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为(盗版)。 当然作者不提倡破解、或盗版。 对于有能力的人，还是支持正版。但是学生嘛，能用就好了。 使用激活工具前，作者建议： ==最好关闭杀毒软件，如果有的话。== 作者没安装360那些，很流畅地激活成功。 ==激活工具无毒的。不关闭的话，可能被误报。== 1).【打开】 界面如下： 这个激活工具还可以xxxxxx。（你懂的） 我啥都没说哦hh 2).【激活】 简单一按，等待激活成功就好。 补充：可能有的电脑打开软件时会提示这个。解决很简单，安装框架就好。 （1）打开“控制面板”。（2）找到并点击“程序和功能”项，在打开的页面中，点击“启用或关闭Windows功能”。（3）在打开的“Windows功能”对话框中，找到并勾选“Microsoft.Net Framework”服务，单击“确定”即可。 使用激活后，就可以安安心心、大大方方地使用 Visio 了。o(￣▽￣)o 【打开】 【新建】新建页面，有一些初始模板可以使用。一般选择“基本框图”就好，然后“新建”。 UTOOLS1574501515942.png 【制图】 左侧可以选择很多官方自带的形状，当然还可以自己建立自己的模型。 右侧可以对图形自定义，包括颜色、线条、端点等等。 结尾使用 Visio 来制图真的很爽。但是，如果只是临时制图使用 Visio ，还得安装确实不太方便。因此 作者还收藏了几个线上制图的网站，在这提供给大家临时使用。 1. https://www.draw.io/ UTOOLS1574501571713.png 2. https://zh.numberempire.com/graphingcalculator.php 3. https://www.processon.com 4. 当然用电脑自带的【画图】也是可以的，你看。 emmm只是好难看啊hhhh。 这就是结尾：如果教程上有什么不足的或者有问题的，可以私信我。谢谢你的阅读！ 本博客第一次发表于【简书】： https://www.jianshu.com/p/32648bcc6f1c 。现转载到作者的网站上。谢谢阅读！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"百合","slug":"百日","date":"2019-11-16T12:54:59.000Z","updated":"2019-11-25T12:23:15.221Z","comments":true,"path":"2019/11/16/百日/","link":"","permalink":"http://yoursite.com/2019/11/16/%E7%99%BE%E6%97%A5/","excerpt":"2019.11.16 星期六 晴天","text":"2019.11.16 星期六 晴天 💙汪曾祺老人的散文《活着多好呀》中“活着多好呀”为汪老一句名言。这位老人不管遇到什么环境，永远不消沉沮丧，守护心中的热情与生机，兴致盎然地生活。💛时光机，这个世界不存在的理想物品。可是我多希望有这东西，真是可惜无法回到两三年前，“时间就是让人猝不及防的东西”……💜有段时间，喜欢黑暗安静的环境。肚子一个人发呆，内室里一个窗户也不开，杜绝所有来往。但已经走出来那段抑郁期，今后不知道，但是现在我挺好的。恍惚发现，最好掩盖哭的方式，除了偷偷一个人，就是洗澡的时候。💚或记日记或写随笔或向月亮倾诉或对空气说说，~生活不易，但也没那么糟糕。柏拉图说：没有什么比健康更快乐的了，虽然在他们生病之前并不曾觉得那是最大的快乐。💗“谢谢你的不告而别”。下辈子，我们再会 ! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"解除课程中心看视频时的“ 窗口获取焦点事件 ”","slug":"解除课程中心看视频时的“ 窗口获取焦点事件 ”","date":"2019-11-16T09:54:59.000Z","updated":"2019-11-23T02:16:39.416Z","comments":true,"path":"2019/11/16/解除课程中心看视频时的“ 窗口获取焦点事件 ”/","link":"","permalink":"http://yoursite.com/2019/11/16/%E8%A7%A3%E9%99%A4%E8%AF%BE%E7%A8%8B%E4%B8%AD%E5%BF%83%E7%9C%8B%E8%A7%86%E9%A2%91%E6%97%B6%E7%9A%84%E2%80%9C%20%E7%AA%97%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%20%E2%80%9D/","excerpt":"前言前段时间，在观看课程中心的马克思视频，因为要至少看到80%以上。 发现那我挂着刷不就得了？偏偏。。。。。 发现这个课程中心存在某个机制——一定要使视频一直处于“置顶”的状态，否者会自动暂停视频。","text":"前言前段时间，在观看课程中心的马克思视频，因为要至少看到80%以上。 发现那我挂着刷不就得了？偏偏。。。。。 发现这个课程中心存在某个机制——一定要使视频一直处于“置顶”的状态，否者会自动暂停视频。 //截断文章 就像下图这样： 操作鼠标前——&gt; image.png 操作鼠标后——&gt; image.png 你会注意到，视频的播放状态跟鼠标的行为有关，准确来说是==和鼠标点击的位置（焦点）有关==。 第一时间想到“这不就是windows的“窗口获取焦点”吗？ 补充先补充补充什么是窗口获取焦点？ 在你浏览其他窗口页面、或是浏览器最小化、又或是点击了程序窗口时，等等都算是浏览器窗口失去焦点，这时候 window.onblur 事件就会触发。 当然，当你的页面获得焦点的时候一样也会触发window.onfocus。 应该有人会注意到过，当你点击不同窗口时，窗口栏会有不同的颜色反馈，就比如win 10的资源管理器，前置窗口和后置窗口的窗口颜色是不是不一样？ image.png 寻找直接按下F12，打开控制台，查看Elements…… emmmmmm结果，没找到对应的代码（或许我没仔细去挖hh） 再试那我直接Console。不就是当前窗口获取了焦点吗？？？？直接暴力敲下代码，并Enter，嘿嘿…… 1javascript:window.onblur=null;void 0 //有无`void 0`，都可以 当我Enter时，诶，成功了hhh效果就是这样。 image.png 后续测试了一段时间后，成功率基本达97%左右。后来就分享到班群，让更多人试试效果。两天刷完所有马克思的视频哈哈有木有？ 建议 一次最多同时两个视频在看，因为后台有个计时器再加上我不会写自动播放、自动静音的脚本hhhhh（有时间再去琢磨哈） 一旦刷新页面，就得重新Enter脚本 极小几率会失败，原因我也不清楚，失败重新Enter即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"脚本","slug":"脚本","permalink":"http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"Java笔记—对象、类","slug":"Java笔记—对象、类","date":"2019-11-15T04:54:59.000Z","updated":"2019-11-30T10:18:12.578Z","comments":true,"path":"2019/11/15/Java笔记—对象、类/","link":"","permalink":"http://yoursite.com/2019/11/15/Java%E7%AC%94%E8%AE%B0%E2%80%94%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB/","excerpt":"Java笔记——对象、类创建时间：2019.11.11 说明：持续更新ing 对象和类的概念。 对象：对象是类的一个实例（实实在在存在的个体），有属性（状态）和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 属性(property)： 静态特征行为(behavior)： 动态特征 类：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。同种类型对象共性的抽象","text":"Java笔记——对象、类创建时间：2019.11.11 说明：持续更新ing 对象和类的概念。 对象：对象是类的一个实例（实实在在存在的个体），有属性（状态）和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 属性(property)： 静态特征行为(behavior)： 动态特征 类：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。同种类型对象共性的抽象 用老师的话来说，就是下面这样——&gt; image.png 下图中男孩（boy）、女孩（girl）为类（class），而具体的每个人为该类的对象（object）： 菜鸟教程.png 【定义类】 image-20191116135106458 Java中的类 类可以看成是创建Java对象的模板。 通过下面一个简单的类来理解下Java中类的定义： 123456789101112public class Student { int id; String name; double score1, score2, score3; public Student(int id, String name) { this.id = id; this.name = name; } public double getAverageScore() { return (score1 ＋ score2 + score3) / 3; } } 一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。一个类可以拥有多个方法。 Java中的对象现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。对比现实对象和软件对象，它们之间十分相似。 软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 创建对象——&gt; 1234567891011/*有两种基本形式*//*1.对象声明和创建*/类名 对象名 = new 类名();Student xiaoming = new Student ();/*2.先声明,后创建*/类名 对象名; // 类(对象)变量对象名 = new 类名(); //实例化Student xiaobai ;xiaobai = new Student(); java对象内存映射像示意.png image.png 类和对象的关系：类是具有相同==属性和方法==的集合，是对对象的抽象描述。 现实生活中的对象：张三、李四。 【想要描述】提取对象中的共性内容。对具体的抽象。 【描述时】这些对象的共性有：姓名、学号、年龄、性别、学习Java等等。（即定义类：描述事物的属性和行为，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。） 映射到Java中，描述就是class定义的类，具体对象就是new建立的实体。 这些描述在Java当中是用类的形式来体现的。而对象是通过Java的new操作符所产生的一个实体，这个的实体存在于==堆内存==当中。 12345678910111213141516171819202122232425//定义类，就是描述事物，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。//需求：描述车汽车（颜色，轮胎数）。class Car { //描述颜色 String color = \"red\"; //描述轮胎数 int num = 4; //运行行为。 void run() { System.out.println(color+\"..\"+num); }}class CarDemo { public static void main(String[] args){ //生产汽车：在Java中通过new操作符来完成。 //其实就是在堆内存中产生一个实体。 Car c = new Car(); //c就是一个【类类型】变量。记住：类类型变量只想对象。 //需求：将已有车的颜色的颜色改成蓝色。指定该对象做使用。 //在Java指挥方式是：【对象.对象成员】 c.color = \"blue\"; //需求：想要车运行起来。 c.run(); }} Car c = new Car();在内存中的示意图——&gt; c.run();——&gt;输出这个车的颜色“蓝色”和轮胎数“4”。 (1)倘若在c.run();后加入Car c1=new Car();c1.run();——&gt; (2)若main的代码块改为： 123456789class CarDemo { public static void main(String[] args){ Car c = new Car(); c.num = 5; Car c1 = c; c1.color = \"green\"; c.run(); }} 在内存中的示意图——&gt; 对对象调用的基本概念：用new建立对象，在堆内存中产生对象。那么对象的特点在于封装数据，数据包含属性和行为。想要操作对象中的内容就指挥对象做事，指挥哪个对象要明确，操作什么也要明确，用对象.xyz的形式就能完成。 【注意】：如下图， 以前定义在函数里面，现在定义在函数外面 【方法】 方法的定义： 方法是类或对象的行为特征的抽象。 Java中的方法不能独立存在，所有的方法必须定义在类中。 使用 “类名.方法” 或 “对象.方法” 的形式调用。 语法格式： 1234权限修饰符 返回值类型 方法名（参数类型 参数名1,参数类型 参数名2,...） { // 方法体 方法语句序列//当返回类型非void时,最后一条被执行语句必须是return语句,返回对应类型的值} 访问权限/权限修饰符（4P权限）： 访问权限 类内 包层内 子类 包层外 public √ √ √ √ protected √ √ √ × package （缺省） √ √ × × private √ × × × return语句： 结束方法调用，并返回值。 return 表达式; return; 🔺方法被调用时,执行到方法内的return语句,则不论方法里是否还有语句未执行,立即结束方法的调用,并将return 后的表达式的值返回方法调用者🔺利用return 语句返回值，仅能返回一个值🔺return语句仅结束方法的执行 🔺void型方法 方法分类： 无参数无返回值 有参数无返回值 无参数有返回值 有参数有返回值 123456789101112131415161718192021222324252627282930public class Method { public void aMethod() { System.out.println(\"无参数无返回值的方法\"); } public void bMethod(int b) { System.out.println(\"有参数无返回值的方法\"); } public int cMethod() { System.out.println(\"无参数有返回值的方法\"); return 10; } public int dMethod(int d) { System.out.println(\"有参数有返回值的方法\"); return d; } public static void main(String[] args) { int ret; // 创建Method类的对象 Method md = new Method(); // 通过对象.方法调用 md.aMethod(); md.bMethod(10); ret = md.cMethod(); ret = md.dMethod(10); System.out.println(ret); }} 方法的参数： 方法可以没有参数，或者有多个参数，参数类型可以是任意类型 方法参数也是局部变量 参数为引用数据类型4时： 当对象实例作为参数传递给方法时，传递的是对象的引用，为地址传递，接受参数的方法可以改变参数的值。 参数为简单数据类型时： 传递的是参数的副本，为值传递，接受参数的方法中不会改变参数的值。 123456789101112131415161718192021222324252627282930313233343536373839public class MethodParam { /** * 方法的参数为基本数据类型时，传递的是值的副本（值拷贝） * 方法中不会改变元参数的值 */ public void swap(int a, int b) {//a, b为形参 int tmp; tmp = a; a = b; b = tmp; } int x = 100, y = 200; /** * 方法的参数为引用数据类型时，传递的对象的引用（传地址） * 方法中可以改变参数的值 */ public void swap2(MethodParam mp) { int tmp = mp.x; mp.x = mp.y; mp.y = tmp; } public static void main(String[] args) { MethodParam mp = new MethodParam(); int m = 10, n = 20; System.out.println(\"交换前：a = \"+m+\",b = \"+n); mp.swap(m, n);// m,n为实参 System.out.println(\"交换后：a = \"+m+\",b = \"+n); System.out.println(\"交换前：x = \"+mp.x+\",y = \"+mp.y); mp.swap2(mp); System.out.println(\"交换后：x = \"+mp.x+\",y = \"+mp.y); }} 普通方法调用——&gt; 成员方法和成员变量的关系——&gt; 【成员方法】和【构造方法】 【成员方法】 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【构造方法】 构造方法需满足以下三个条件 ： 1、方法名与类名同名 2、在方法中不能使用 return 语句，即无返回值 3、在方法名的前面*没有返回值的类型声明 * （有看到“ 构造方法无返回值也不可以加void，但其实返回的是首地址 ”这话还得去证实，先放在这里） image.png ==老师推荐==：显式无参构造子,作为一种良好实践,定义了其他构造子，那就准备一个无参构造子 12345678910111213package me;public class Me { private String name; //成员变量 public Me(String name){ //构造方法 this.name = name; } public String getName() { //成员方法 return name; } public void setName(String name) {//成员方法 this.name = name; }} 我如果我在添加一age 如下 添加方法依然是成员方法 , 1234567891011121314151617181920package me;public class Me { private String name; //成员变量 private String age; //成员变量 public Me(String name){ //构造方法 this.name = name; } public String getName() { //成员方法 return name; } public void setName(String name) {//成员方法 this.name = name; } public String getAge() {//成员方法 return age; } public void setAge(String age) {//成员方法 this.age = age; }} 个人理解：无论多少方法，==除了构造方法外，其余都是成员方法==，当然这样理解可能有点偏见.. 它们的区别： 构造方法一般是给对象的数据进行初始化,没有返回值 成员方法一般实现对类中成员变量的操作，提供某些功能,有返回类型，可以为void类型 成员方法与构造方法调用的区别 123456789package me;public class Book { public static void main(String[] args) { Me me = new Me(\"张三\");//构造方法调用 System.out.println(me); me.setName(\"李四\");//成员方法调用 System.out.println(me.getName()); }} 从上面的demo中可以看出，==构造方法通过new运算符调用==，==成员方法通过对象调用==。 注意：类中除了构造方法以外的方法都是成员方法。原因是在类中，除了变量外的基本都是成员方法。 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【this 关键字】 https://i.loli.net/2019/11/16/49d7AMODXhKbsuy.png ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【重载构造方法之间的调用】 image.png image.png 【含对象成员的构造方法调用】 image.png image.png 【无继承情况下的对象初始化顺序】 image.png 【创建对象】 对象是根据类创建的。在Java中，使用关键字new 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 下面是一个创建对象的例子： 12345678910public class Puppy{ public Puppy(String name){ //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public static void main(String[] args){ // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); } } 编译并运行上面的程序，会打印出下面的结果： 1小狗的名字是 : tommy ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【访问实例变量和方法】 通过已创建的对象来访问成员变量和成员方法，如下所示： 123456/* 实例化对象 */ Object referenceVariable = new Constructor(); /* 访问类中的变量 */ referenceVariable.variableName; /* 访问类中的方法 */ referenceVariable.methodName(); ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【访问实例变量】和【调用成员方法】： 1234567891011121314151617181920212223public class Puppy{ int puppyAge; public Puppy(String name){ // 这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public void setAge( int age ){ puppyAge = age; } public int getAge( ){ System.out.println(\"小狗的年龄为 : \" + puppyAge ); return puppyAge; } public static void main(String[] args){ /* 创建对象 */ Puppy myPuppy = new Puppy( \"tommy\" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(\"变量值 : \" + myPuppy.puppyAge ); } } 编译并运行上面的程序，产生如下结果： 123小狗的名字是 : tommy小狗的年龄为 : 2变量值 : 2 【方法重载，重构，覆盖，重写的区别】 方法重载还是比较好理解的，就是在类的内部，定义多个方法，这些方法的方法名字相同，参数类型、参数顺序、参数个数不同，注意，返回值类型并不能区分重载 。 123456789public void show(int a,double b){}public void show(double c){} public int show(double d){ return 1;} //报错，方法已经定义了 方法重写（override)方法重写和方法覆盖都是一个道理，发生在子类继承父类或者实现接口的类，要求的是： 1.方法名字相同，2.参数个数不同，3.返回值类型不同 ， 代码： 方法重构 定义：在不改变外界外界访问的情况下对代码进行修改，但是不改变原方法的效果，提高其性能，使程序更加易读，可维护。重构是在不改变软件可观察行为的前提下改善其内部结构重构通常不是一次性的，它贯穿软件的整个生命周期，只要觉得不合理都是重构的时机。 题目：下面说法中，错误的有（ ） ​ A. Java面向对象语言容许单独的过程与函数存在； ​ B. Java面向对象语言容许单独的方法存在； ​ C. Java语言中的方法属于类中的成员（member）； ​ D. Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同。 答案：ABC 解释： 方法与函数：这两个概念不严格区分，就是一个东西，通过对象调用的，就是方法，直接调用，就是函数； 在java中，everything is object 所以，方法，函数，必须隶属于某一个类或对象， java中没有过程。（类中的代码块不知道算不算，就算代码块是过程，也是必须在类中才有的） 对于C选项，方法分为静态方法和非静态方法，静态方法属于类成员，非静态方法属于实例成员。 类其实一种类型，它封装了数据和操作。 对象是类的实例 一个对象比属于某个类 一个类可以声明多个对象 问：构造方法可以调用本类的其他方法吗？ 1,构造方法可以调用本类的其他方法。既然可以调用本类的属性,那么也就可以调用属于本类的其他方法。 2,需要注意的是,如果要在构造方法里调用一个非静态方法时,应该将该方法声明为private。因为如果这个类被其他类继承成为父类时,这个方法不是private的又被子类所重载，这样在实际创建子类的过程中递归调用到了父类的构造器时，父类构造器对这个方法的调用就会由于多态而实际上调用了子类的方法，当这个子类方法需要用到子类中实例变量1的时候，就会由于变量没有初始化而出现异常（子类中的实例变量没有初始化这种情况还是会遇见的），这是Java不想看到的情况。 一个类的构造方法有多个，在其他类中是否可以被调用？ 只要不是私有的构造函数，在其他类中就可以调用。 传对应的参数就行了 。 12345678910class` `A{ ``public` `A(String s){} ``public` `A(``int` `n){} ``public` `A(String s, ``int` `n){}}class` `B{ ``A a1 = ``new` `A(``\"abc\"``); ``A a2 = ``new` `A(``1``); ``A a3 = ``new` `A(``\"aaa\"``,``2``);} 类是一种引用类型。 Java的引用类型只有三种，分别是 类(class) 接口(interface) 数组 参考资料 问：方法一定是在类内部被定义的？ 所有方法必须写在类体里，也包括构造方法2的。 static方法同样属于类，叫类方法或静态方法，它与类一同被加载时，处于内存的公共代码区中，无需创建实例来调用，只需用类名引用即可。 static方法既可以通过类名来调用，也可以通过类的实例调用。 Java一切都是以类的形式存在，方法是类的一部分，需要通过类才能进行方法的调用。 从内存存储角度来说，java中找对应方法时，都是先找对应类实例，类实例是根据类来初始化内存的。如果方法在类外部，则无法找到该方法。 所以方法必须在类体里。 注意： 可以在其他类里使用这个类的方法（在不同的包下就要引ltem这个类），继承就是一个类从另一个类继承通过关键字extends 来实现 问：构造方法中可不可以有return语句呢? （这个解释有问题？）可以。而是我们写成这个样子就OK了：return; 其实，在任何的void类型的方法的最后你都可以写上：return; 问：非构造方法的一般成员方法必须有return语句？ 错。 （待补充……） 问：类中的数据成员可以按需选择任意类型，包括类本身？ 可以。可以参考下图，图源于陈三千的博客 问：Java中构造函数的权限可以是private吗？ 可以，这个类就不能再外部被new了，如果需要这个类的实例化对象，就只能在类内部提供静态方法生产这个类的对象了。 问：构造方法能不能被重载，构造方法能不能被重写？ 在回答这两个问题之前，首先先回顾：什么是构造方法？构造方法的特点是什么？ 概述：构造方法存在于类中，给对象数据（属性）初始化； 特点：方法名与类名一样；无返回值无void; 默认构造方法：我们不创建一个构造方法时，系统默认提供一个无参构造；当我们创建一个构造方法时，系统不再提供无参构造，所以在实际项目中，全部手动给出无参构造 其次\\什么是重载？什么是重写？** 重载：存在于在一个类中，方法名相同，方法参数的类型或个数不同 重写：存在于子父类中，方法名、方法参数、返回值全部相同 所以：构造方法可以重载，不能重写 在一个类中，可以有多个构造方法（方法参数不同） ，即重载，来实现对象属性不同的初始化； 但是子类中不能定义一个方法无void无返回值的方法，编译错误，即子类无法继承构造方法，但是子类的构造器中可以调用父类的构造方法（默认自动调用无参构造） 注意：回答来源于 CSDN博客 Java中可以定义一个空类（即没有数据成员和成员方法） 。 问： 下面这个类有几个构造方法？ 1class A{} 1个。（待补充……） 问：Java 类可以作为（ C ） A．类型定义机制 B．数据封装机制 C．类型定义机制和数据封装机制 D．上述都不对 用于定义类头的修饰符可以是public、abstract、final或者是默认(friendly) 题目：下列说法错误的有（ CD ） A． 在类方法中可用this来调用本类的类方法B． 在类方法中调用本类的类方法时可直接调用 C． 在类方法中只能调用本类中的类方法 D． 在类方法中绝对不能调用实例方法 C：类方法可以调用外部其他类的方法。D：只要实力化对象，也是可以调用实例方法的。 判断： 只有基本类型的参数传递使用值传递。 错误。 引用类型参数的传递，依然是值传递。但因为是地址值，所以会指向同一个对象实例。 Java中方法的参数传递是值传递（pass by value），并且为单向传递。 《Java 变量参数传入方法，修改后是否影响外面的值》。参考 博客 《某个变量当作函数的参数传递后，函数内部修改了。到底这个变量是否受影响》。参考 博客 问：类设计get方法和set方法的作用是什么？ 答1：一般类的成员变量被设置为private（私有的），这样设置安全性比较高，但是设置为私有的后其他的类和对象则无法调用该对象了，所以会有get和set方法，这两个方法一般设置为public，在其他的类中通过对象调用set或get方法即可操作私有的变量，增强程序的安全性，set为给对象赋值的方法，而get则是取得变量值的方法！ 答2：get set常用在自定义类，类创建了一个实例对象后，用set设置对象的某一个属性，get得到对象某一属性。如果不使用get set，你就得用点，点出来还得是个方法。其实就是给get set换个名而已。而且get set作为内部方法，可以访问私有数据 答3：别说的那么专业化了，理解都要半天。就这么理解吧，面向对象中，想对类的成员变量设置访问一些权限，于是，就将该字段设置为private的，这样别的类就不能访问了，然后在该内定义两个方法，一个专门用于获取，一个用于修改，这样，在你不想让别人乱动该字段的时候，就在该方法内写一些限制条件。而为了规范起见（团队开发需要嘛），就根据人家老外的习惯，将方法名设置为set+字段名，get+字段名（名字乱改没问题），既然规范了，那就是别人都叫这名了，于是，有些框架给对象赋值就有方法了，方法名称由get或set开始的又有private变量名的，就找出来调用。hibernate1框架就这样弄得，至于后面的版本是不是这样就不大清楚了。JavaBean就是一个JAVA类，既然是JAVA类就不需要什么组件了，这玩意直接深入到虚拟机了的 Java的包装类： 【包装类的概念】 【Integer类的用法】 image.png 【自动装箱机制和自动拆箱机制】 image.png 匿名对象： 使用方法： 当对对象的方法只调用一次，可以使用匿名对象来完成，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。 可以将匿名对象作为实际参数进行传递。 注脚：1.实例变量（全局变量）、成员变量、实例变量、属性 ↩2.java的构造方法、java的构造方法、Java入门：构造方法 ↩3.来创建一个新的对象。创建对象需要以下三步： ↩3.java之new的用处 ↩4.JAVA中基本数据类型和引用数据类型区别 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—面向对象","slug":"Java笔记—面向对象","date":"2019-11-13T04:54:46.000Z","updated":"2019-11-29T17:35:40.535Z","comments":true,"path":"2019/11/13/Java笔记—面向对象/","link":"","permalink":"http://yoursite.com/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"Java笔记——面向对象创建时间：2019.11.11 说明：持续更新ing Java作为一种面向对象语言。支持以下基本概念： 多态 | 继承 | 封装 | 抽象 类 | 对象 | 实例 | 方法 | 重载 “面向对象”和“面向过程”的区别： 面向过程：如 C/C++ 例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。强调过程，“打开”、“存储”、“关闭”三个动作。注重过程，注重的是过程涉及的行为（即功能）。 面向对象：如 Java 将功能封装进对象，强调具备了功能的对象。 image.png 面向对象是基于面向过程的。","text":"Java笔记——面向对象创建时间：2019.11.11 说明：持续更新ing Java作为一种面向对象语言。支持以下基本概念： 多态 | 继承 | 封装 | 抽象 类 | 对象 | 实例 | 方法 | 重载 “面向对象”和“面向过程”的区别： 面向过程：如 C/C++ 例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。强调过程，“打开”、“存储”、“关闭”三个动作。注重过程，注重的是过程涉及的行为（即功能）。 面向对象：如 Java 将功能封装进对象，强调具备了功能的对象。 image.png 面向对象是基于面向过程的。 使用不同思想，对“冰箱装大象”的理解——&gt; 问：“人开冰箱”事件，其中人、冰箱都是实物（对象），开是动作。若使用面向对象思维，“开”的这个动作是属于“人”还是属于“冰箱”？ 答：属于“冰箱”，“人”只是调用了“冰箱”的“开”的方法（或功能），用力作用了门一下并将门打开了。 1234567891011121314人开门：名词提炼法。/*人{ 开门（门）{ 门.开（）; }}门{ 开（）{ 操作门轴; ……等等; }}*/ 面向对象的三个特征：封装、继承、多态。 以后开发：其实就是找对象使用，没有对象就创建一个对象。 找对象，建立对象，使用对象，维护对象的关系。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—语法","slug":"Java笔记—语法","date":"2019-11-13T04:54:20.000Z","updated":"2019-11-29T17:36:18.031Z","comments":true,"path":"2019/11/13/Java笔记—语法/","link":"","permalink":"http://yoursite.com/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E8%AF%AD%E6%B3%95/","excerpt":"Java笔记——语法创建时间：2019.11.11说明：持续更新ing 单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。 Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。 布尔型常量只有2个值：true、false 标识符由字母：26个，大小写；数字：0- 8；符号：$ _ 组成。 标识符不能数字开头、不能使用关键字 main不是关键字，但是是被JVM识别的名字，是程序的入口 Java中的名称规范： 包名：多单词组成，全为小写 xxxyyyy 类名接口： 多单词组成，所有单词的首字母大写 XxxYyyZzz 变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写 xxxYyyZzz 常量名：所有字母都大写。每个单词用_隔开 XXX_YYY_ZZZ","text":"Java笔记——语法创建时间：2019.11.11说明：持续更新ing 单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。 Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。 布尔型常量只有2个值：true、false 标识符由字母：26个，大小写；数字：0- 8；符号：$ _ 组成。 标识符不能数字开头、不能使用关键字 main不是关键字，但是是被JVM识别的名字，是程序的入口 Java中的名称规范： 包名：多单词组成，全为小写 xxxyyyy 类名接口： 多单词组成，所有单词的首字母大写 XxxYyyZzz 变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写 xxxYyyZzz 常量名：所有字母都大写。每个单词用_隔开 XXX_YYY_ZZZ //截断文章 注释，写在代码前面 对于整数：Java有三种表现形式。· 十进制：0-9，满10进1· 八进制：0-7，满8进1，用0开头表示· 十六进制：0-9，A-F或a-f（A\\a是10，B\\b是11…F\\f是15），满16进1，用0x开头表示 null常量：只有一个值null。在对象、引用数据类型时会用上。 二进制。一个字节8位0、1组合。 八进制：3位二进制位代表1位八进制位；十六进制：4位二进制位代表1位十六进制位。进制转换：进制越大，表示越短，更方便地表示数据。 二进制计算：5 + 4 = 9 十进制转二进制.png 进制之间转换.png 负数地二进制表现形式：对应的整数二进制取反加1。负数的最高位都是1 负数的二进制.png document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"博客v1.4上线","slug":"博客v1.4","date":"2019-11-08T14:30:21.000Z","updated":"2019-11-29T17:39:13.419Z","comments":true,"path":"2019/11/08/博客v1.4/","link":"","permalink":"http://yoursite.com/2019/11/08/%E5%8D%9A%E5%AE%A2v1.4/","excerpt":"搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了","text":"搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了 //截断文章 新增 主页动画，点击体验效果（这里） 文字跳动（menu、head中的文字均可跳动）,比如顶部的“你用走，可是我用跑”…… 新增Valine评论（可以使用表情；发送前浏览）。想用别的，但是暂时先着Valine。可以试着来骚扰我（滑稽~~ 有评论，邮件提示(还未测试)。接入Leancloud（文档）。 底部开启鼠标滑动渲染 开启“一言”api。menu中作者名（Melody Jerry）下面随机显示一句话。同时，使用文字扭曲动画。 修复 1.重写三个按钮（menu、搜索、回到顶部）的代码，现在可以正常使用了。 更新menu的Github的url 修复移动端提示证书错误的问题（移动端重定向太多次了，难怪hhh） 主页和首页分仓（也不算是修复，不知道写哪而已） 已知问题（加粗的为重要问题） menu中的“分类”、“标签”、“关于”，仍然无法正常使用（原因未知） menu的Email仍旧无法mailto 文章增加标签或类名，无法被tags或categories绑定 浏览人数、浏览次数，无法使用（接口有问题？） 文字截断，异常。（原因位置） 等待发现 未来加入 音乐控件（自动？手动？浮窗？嵌入？音源线上还是本地？） 实时颜色 加载网页时、侧栏、搜索、进度条等动画 留言板？ 友情链接？快速导航？ 嵌入播放（这个很想要，链接一些学习视频） 天气控件 等待脑洞大开 最后从早上9点搞到下午4点，午饭还没吃hh，就一直坐在电脑前。找模板中的问题代码、修改代码，还是很麻烦的。最后分享一首今天网易日推的英文歌（版权原因，没法生成外联播放器）I’ll Be There-Jess Glynne对于我的博客有问题或建议，欢迎在评论或邮件中告诉我。谢谢每一位读者。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"多图片滚动测试","slug":"多图片滚动测试","date":"2019-11-07T23:10:13.000Z","updated":"2019-12-01T06:31:24.901Z","comments":true,"path":"2019/11/08/多图片滚动测试/","link":"","permalink":"http://yoursite.com/2019/11/08/%E5%A4%9A%E5%9B%BE%E7%89%87%E6%BB%9A%E5%8A%A8%E6%B5%8B%E8%AF%95/","excerpt":"","text":"无缝滚动 *{margin: 0;padding: 0;} #div1{position: relative;border:1px solid #0ff;width:800px; height: 180px;margin:50px auto 0;overflow: hidden;} /* 修改容器规模 */ #div1 ul{position: absolute;left: 0;} #div1 ul li{list-style: none;width:200px;float: left;padding: 10px;height: 160px;} #div1 ul li img{width:100%;} window.onload=function(){ var oDiv=document.getElementById('div1'); var oUl=oDiv.getElementsByTagName('ul')[0]; var aLi=oUl.getElementsByTagName('li'); var aA=document.getElementsByTagName('a');//获取向右向左的箭头 var timer=null; var iSpeed=10; oUl.innerHTML+=oUl.innerHTML;//定义图片可以循环播放 oUl.style.width=aLi.length*aLi[0].offsetWidth+'px';//定义外层ul的宽度，根据图片的个数和每个图片的宽度计算，保证总宽度是可调整的 function fnMove(){ if(oUl.offsetLeft0){ oUl.style.left=-oUl.offsetWidth/2+'px'; }//定义到边界的时候，实现无缝衔接 oUl.style.left=oUl.offsetLeft+iSpeed+'px'; //定义图片的右边距随着速度不断不断增加，或减小，实现运动的效果 } timer=setInterval(fnMove,30); aA[0].onclick=function(){ iSpeed=-10; //按下左箭头，定义向左运动 } aA[1].onclick=function(){ iSpeed=10; //按下右箭头，定义向右运动 } oDiv.onmouseover=function(){ clearInterval(timer); //鼠标移动到图片上，清除定时器，停止运动 } oDiv.onmouseout=function(){ timer=setInterval(fnMove,30); //鼠标移出，重新开启定时器，重新运动 } }; ←→！！！方向选择按钮异常！！！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"网页视频测试","slug":"网页视频测试","date":"2019-11-07T16:00:00.000Z","updated":"2019-11-25T14:12:49.754Z","comments":true,"path":"2019/11/08/网页视频测试/","link":"","permalink":"http://yoursite.com/2019/11/08/%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E6%B5%8B%E8%AF%95/","excerpt":"浏览测试效果👇","text":"浏览测试效果👇 video大窗口 video小窗口 embed窗口 iframe窗口 测试完毕 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"使用Hexo+GitHub建站","slug":"Hexo+GitHub","date":"2019-11-07T11:24:01.000Z","updated":"2019-11-23T11:49:16.133Z","comments":true,"path":"2019/11/07/Hexo+GitHub/","link":"","permalink":"http://yoursite.com/2019/11/07/Hexo+GitHub/","excerpt":"前言： 使用CSDN平台撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。","text":"前言： 使用CSDN平台撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。 //截断文章 安装篇 一、安装 【hexo】 前的准备安装hexo前的必要工作1).安装以下两个程序： 程序 下载地址 说明 Git Git - Downloads 网速的同学，可以自行百度移步到国内镜像 Node.js Node.js - Downloads 有LTS和Current两个版本，安装 LTS 版即可 注意：关于Git和Node.js的安装可能会有问题，尤其是Git的安装。这里贴上几张安装界面的截图（来源见水印，作者GroovRain）。 image.png f3e0287f.png 774cdfb9.png 2e023781.png 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ image.png 2).配置（可以在未来部署，并非一定现在） 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 $ git config --global user.name \"your name\"` $ git config --global user.email \"your Email\"二、正式安装【hexo】 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。——官方 准备工作完成后，来安装hexo框架吧！ == 主要根据hexo官方的文档来安装hexo == ==使用 npm 安装 Hexo== $ npm install -g hexo-cli image.png 这样,【hexo】就安装完成了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"博客文章太长？截断！","slug":"文章截断","date":"2019-11-06T08:49:56.000Z","updated":"2019-11-23T11:49:29.633Z","comments":true,"path":"2019/11/06/文章截断/","link":"","permalink":"http://yoursite.com/2019/11/06/%E6%96%87%E7%AB%A0%E6%88%AA%E6%96%AD/","excerpt":"","text":"写的md文章太长，担心放到首页上浏览效果不好，怎么办？ 那就直接截断文章。 截断按钮文字不是通过配置文件_config.yml实现的，而是在文章内容里实现。 只要在需要被截断的文章位置加上： 1&lt;!-- more --&gt; 就可以了！ 效果就像下面的这个按钮 可以点点看哦👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}]}